#! /usr/bin/perl

use strict;
use warnings FATAL => 'all';

use Data::Dump qw(pp);
use Getopt::Long;
use Ptero::HTTP qw();

exit main();

sub main {
    my ($package_name, $subroutine_name) = get_options();
    validate_environment();

    use_package($package_name);

    my $inputs = get_inputs();
    my $outputs = do {
        no strict 'refs';
        &{"${package_name}::${subroutine_name}"}($inputs);
    };
    if (ref($outputs) ne ref({})) {
        die sprintf("Subroutine failed to return hashref: %s::%s(%s)",
            $package_name, $subroutine_name, pp($inputs));
    }

    set_outputs($outputs);
    return 0;
}

sub get_options {
    my ($package_name, $subroutine_name);

    unless (
        GetOptions("package=s" => \$package_name,
            "subroutine=s" => \$subroutine_name)
        && defined($package_name) && defined($subroutine_name)
    ) {
        print STDERR "Usage: ptero-perl-subroutine-wrapper --package <Some::Package> --subroutine <some_subroutine>\n";
        exit 1;
    }

    return ($package_name, $subroutine_name);
}

sub validate_environment {
    unless (defined $ENV{PTERO_WORKFLOW_EXECUTION_URL}) {
        print STDERR "ptero-perl-subroutine-wrapper: Environment variable PTERO_WORKFLOW_EXECUTION_URL must be set\n";
        exit 1;
    }
}

sub get_inputs {
    my $r = Ptero::HTTP::get($ENV{PTERO_WORKFLOW_EXECUTION_URL});
    return Ptero::HTTP::decode_response($r)->{inputs};
}

sub set_outputs {
    my ($outputs) = @_;
    my $url = $ENV{PTERO_WORKFLOW_EXECUTION_URL};
    my $r = Ptero::HTTP::patch($url, {outputs => $outputs});
    unless ($r->is_success) {
        die sprintf("Unexpected response code (%s: %s) whlie patching %s: %s",
            $r->code, $r->message, $url, pp($outputs));
    }
    return;
}

sub use_package {
    my ($package_name) = @_;

    my $error = do {
        local $@;
        eval "use $package_name qw();";
        $@;
    };

    if ($error) {
        die "Could not use package '$package_name': $error";
    }
}
